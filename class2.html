<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>GDI Introduction to Java and OOP Concepts</title>

	<meta name="description" content="Intro to Object Oriented Programming with Java curriculum was developed by Ashley Price for Girl Develop It.   The course is meant to be taught in 2 4-hour sections.  The slides are customizable according to the needs of a given class or audience.">
	<meta name="author" content="Girl Develop It">

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<link rel="icon" href="images/favicon.ico">

	<link rel="stylesheet" href="reveal/css/reveal.css">
	<link rel="stylesheet" href="reveal/css/theme/serif.css" id="theme">
	<link rel="stylesheet" href="css/gdi.css">

	<!-- For syntax highlighting -->
	<link rel="stylesheet" href="reveal/plugin/highlight/styles/zenburn.css">

	<!-- For the slides -->
	<link rel="stylesheet" href="css/slides.css">

	<!-- If use the PDF print sheet so students can print slides-->
	<link rel="stylesheet" href="reveal/css/print/pdf.css" type="text/css" media="print">

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<!-- Opening slide -->
			<section>
				<img src="images/gdi_logo_badge.png" alt="" />
				<h3>Intro to Java and OOP Concepts</h3>
				<h4>Class 2</h4>
				<h5 class='title-page'>Developed for GDI by Ashley Price</h5>
			</section>

			<!-- Welcome-->
			<section>
				<h3>Welcome!</h3>
			</section>
			<section>
				<section>
					<h3>Review - Variables</h3>
						<ul>
							<li>Stronly typed</li>
							<li>Primatives</li>
							<li>Objects</li>
						</ul>
					</section>
					<section>
						<h3>Review - Flow Control</h3>
						<ul>
							<li>Choices</li>
							<ul>
								<li>If/Else</li>
								<li>Swtich</li>
							</ul>
							<li>Loops</li>
							<ul>
								<li>For Loops</li>
								<li>While Loops</li>
							</ul>
						</ul>
					</section>
					<section>
						<h3>Review - Objects</h3>
						<ul>
							<li>States - Also called properties and data members</li>
							<li>Behaviors - actions the object can take.  Known as methods</li>
						</ul>
					</section>
			</section>
			<section>
				<h3>Agenda</h3>
				<ul>
					<li>Objects and Classes</li>
					<li>Defining Fields and Methods</li>
					<li>Data Encapsulation</li>
					<li>Subclasses and Inheritance</li>
					<li>Polymorphism</li>
					<li>Abstraction</li>
					<li>Interfaces</li>
				</ul>
			</section>
			<section>
				<h3>Featured Object</h3>
				<p>MotorVehicles which are types of Vehicles and include cars and buses</p>
			</section>
			<section>
				<aside class='notes'>
					Create an "Interface" based on this discussion<br>
					Have an engine whose state can be on or off<br>
					you can turn an engine on<br>
					you can turn  an engine of<br>
					------<br>
					Have a current speed<br>
					accelerate<br>
					decelerate<br>
					check your current speed -- accessor method<br>
					------<br>
					color<br>
					maximum number of passengers -accessor method<br>
					current number of passengers -- accessor method<br>
				</aside>
				<p>Describe a Motor Vehicle's states and behaviors</p>
			</section>
			<section>
				<section>
					<aside class='notes'>
						Think of how with a single recipe you can create cookies MANY times...<br>
						Note to self: Bring cookies to class
					</aside>
					<h3>Classes</h3>
					<p>A Class is a blueprint of an Object</p>
					<p>It tells us how to build an instance of an Object.</p>
					<p>From one blueprint we can create many instances of a single Object</p>
				</section>
				<section>
					<h3>Class Declarations</h3>
					<p>When defining a class you must include: </p>
					<pre><code class='java'>
class ClassName {
	...
}
					</code></pre>
				</section>
				<section>
						<h3>Create a new project</h3>
						<ol>
							<li>File > New > Project</li>
							<li>Project name: com.gdi.vehicles</li>
						</ol>
					</section>
					<section>
						<h3>Create a new class with a main method</h3>
						<ol>
							<li>File > New > Class</li>
							<li>Class Name: tester</li>
							<li>Under <em>which methods would you like to create?</em>, check "public static void main(String[] args)"</li>
					</section>
					<section>
						<h3>Create a new class</h3>
						<ol>
							<li>File > New > Class</li>
							<li>Class Name: MotorVehicle</li>
						</ol>
					</section>
				</section>
				<section>
					<h3>The Code</h3>
					<pre><code class='java'>
public class MotorVehicle {
}
					</code></pre>
				</section>
			</section>
			<section>
				<section>
					<aside class='notes'>
						Flip back to our notes and list the data members
					</aside>
					<h3>Data Members</h3>
					<p>An Object has one or more data members that describe its state.</p>
				</section>
				<section>
					<aside class='notes'>
						public class MotorVehicle {<br>
						boolean engineOn;<br>
						int currentSpeed;<br>
						int maxNumberPassengers;<br>
						int numCurrentPassengers;<br>
						}<br>
					</aside>
					<h3>Defining Data Members</h3>
					<pre><code class='java'>
boolean engineOn;
int currentSpeed;
					</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h3>Defining a Constructor</h3>
					<p>When you create an Object, you should include at least one constructor.  If you do not, the compiler automatically provides a default one.</p>
					<p>A constructor is a special method that is invoked when you create a new instance of your object</p>
					<p>It is common to set default values for your data members in the constructor</p>
				</section>
				<section>
					<h3>Code It!</h3>
					<pre><code class='java'>
	public MotorVehicle() {
		currentSpeed = 0;
		engineOn = false;
	}
				</code></pre>
			</section>
		</section>
		<section>
			<section>
				<h3>Defining Methods</h3>
				<p>Method represent the behavior of the Objects.</p>
				<p>A method signature includes the method's name plus the number and type of paramters</p>
			</section>
			<section>
				<aside class='notes'>
					addPassenger?<br>
					removePassenger?
				</aside>
				<h3>MotorVehicle Methods</h3>
				<pre><code class='java'>
public void accelerate();
public void decelerate();
				</code></pre>
			</section>
			<section>
				<h3>Code It!  (Adding Methods)</h3>
				<p>Let's add an accelerated method to our MotorVehicle class: </p>
				<pre><code class='java'>
public void accelerate() {
	currentSpeed = currentSpeed + 5;
}
				</code></pre>
			</section>
			<section>
				<aside class='notes'>
					void decelerate(){<br>
					currentSpeed = currentSpeed - 5;<br>
					}<br>
					<br>
					void addPassenger(){<br>
					currentNumPassengers++;<br>
					}<br>
					<br>
					void removePassenger{<br>
					currentNumPassengers--;<br>
					}
				</aside>
				<h3><span class='individually'>Individually</span></h3>
				<p>Add a decelerate method that slows the motor vehicle down in increments of 5.</p>
				<p>Add a method that will swtich the engine's state</p>
				<p><em>If</em> the engine is on turn the engine off</p>
				<p><em>else</em> the engine is off so turn the engine on</p>
			</section>
			<section>
				<h3>The Code</h3>
				<pre><code class='java'>
public void decelerate() {
	currentSpeed = currentSpeed - 5;
}

public void switchEngineState() {
	if (engineOn == true) {
		engineOn = false;
	}
	else {
		engineOn = true;
	}
}
				</code></pre>
			</section>
		</section>
		<section>
			<section>
				<p>You build an Object from a class</p>
				<p>Objects are instances of your classes</p>
			</section>
			<section>
				<h3>Objects - Creating </h3>
				<p>To create an object:</p>
				<pre><code class='java'>
ObjectType nameOfInstance = new ObjectType();
				</code></pre>
				<p>where ObjectType() is the Object's constructor.  If the constructor expects parameters you would include them in this statement: </p>
				<pre><code class='java'>
nameOfInstance = new ObjectType(String ex);
				</code></pre>
			</section>
			<section>
				<h3>Code It!</h3>
				<p>Create a MotorVehicle Object</p>
				<p>In the main method of the Tester class, add the following line: </p>
				<pre><code class='java'>
MotorVehicle myVehicle = new MotorVehicle();
				</code></pre>
			</section>
		</section>
		<section>
			<section>
				<h3>Using Objects</h3>
				<p>Once you have created your object, you can call its different methods with the following format: </p>
				<pre><code class='java'>
nameOfInstance.methodName();
				</code></pre>
				<p>Similarly, you can access data members in this format: </p>
				<pre><code class='java'>
nameOfInstance.datamember;
				</code></pre>
			</section>
			<section>
				<aside class='notes'>
					MotorVehicle myVehicle = new MotorVehicle();<br>
					myVehicle.switchEngineState();<br>
					System.out.println("Engine is On: "+myVehicle.engineOn);<br>
					System.out.println("Current Speed: "+myVehicle.currentSpeed);<br>
					myVehicle.accelerate();<br>
					System.out.println("Current Speed: "+myVehicle.currentSpeed);<br>
					myVehicle.decelerate();<br>
					System.out.println("Current Speed: "+myVehicle.currentSpeed);<br>
					<br>
					<strong>output:</strong><br>
					Engine is on: true<br>
					Current Speed: 0<br>
					Current Speed: 5<br>
					Current Speed: 0
				</aside>
				<h3>Code It!</h3>
				<p>Now use a method of your motor vehicle class: </p>
				<ol>
					<li>call switchEngineState to turn on the car</li>
					<li>Print engineOn and confirm it's true</li>
					<li>Print the currentSpeed</li>
					<li>Accelerate the vehicle</li>
					<li>Print the new currentSpeed</li>
					<li>Decelerate the vehicle</li>
					<li>Print the new currentSpeed</li>
				</ol>
			</section>
			<section>
				<h3>The Code</h3>
				<pre><code class='java'>
MotorVehicle myVehicle = new MotorVehicle();
myVehicle.switchEngineState();
System.out.println("Current Speed: " + myVehicle.currentSpeed);
myVehicle.accelerate();
System.out.println("Current Speed: " + myVehicle.currentSpeed);
myVehicle.decelerate();
System.out.println("Current Speed: " + myVehicle.currentSpeed);
				</code></pre>
				<p>Output:</p>
				<pre><code class='no-highlight'>
Current Speed: 0
Current Speed: 5
Current Speed: 0
				</code></pre>
			</section>
			<section>
				<aside class='notes'>
					public void printDescription(){<br>
					System.out.println("I'm a Motor Vehicle and my Engine is on "+engineOn+" and i'm going "+currentSpeed+"mph");<br>
					}<br>
				</aside>
				<h3><span class='individually'>Individually</span></h3>
				<p>Create a method called printDescription that will print the following statement:</p>
				<pre><code class='no-highlight'>
I'm a MotorVehicle and my engine is on (true/false) and 
I'm currently going (#)mph.
				</code></pre>
				<p>Test it by calling myVehicle.printDescription();</p>
			</section>
			<section>
				<h3>The Code</h3>
				<pre><code class='java'>
public void printDescription	() {
	System.out.println("I'm a MotorVehicle and my engine is on " + engineOn + 
		" and I'm currently going " + currentSpeed + " mph.");
}
				</code></pre>
			</section>
		</section>
		<section>
			<h3>Checkpoint</h3>
			<p>Building basic Objects</p>
			<ul>
				<li>Methods</li>
				<li>Data Members</li>
				<li>Instances</li>
			</ul>
		</section>
		<section>
			<section>
				<aside class='notes'>
					We've already seen this with the public modifiers on our class declaration and method declaration
				</aside>
				<h3>Data Members - Access Modifiers</h3>
				<p>We can make these data members public or private</p>
				<p>Public members can be accessed by all other classes</p>
				<p>Private memembers can only be accessed within its own class</p>
			</section>
			<section>
				<h3>Code It!</h3>
				<p>Mark your data members public and private</p>
				<pre><code class='java'>
public boolean engineOn;
private int currentSpeed;
				</code></pre>
			</section>
			<section>
				<h3>Accessing Data Members</h3>
				<p>If your fields are declared with the <em>public</em> access modifier you can access the data members directly with the format mentioned before: </p>
				<pre><code class='java'>
instanceOfObject.fieldName
				</code></pre>
			</section>
			<section>
				<aside class='notes'>
				The field MotorVehicle.currentSpeed is not visible<br>
				b/c currentSpeed is now private<br>
				b/c it's public
				</aside>
				<h3>Oops!</h3>
				<p>What is the error we received?</p>
				<p>Why did we receive it?</p>
				<p>Why is myVehicle.engineOn not throwing the same error?</p>
			</section>
		</section>
		<section>
			<section>
				<h3>Data Encapsulation</h3>
				<p>With OOP, we have the concept of data encapsulation which discourages the direct, public access to a class's data members.</p>
			</section>
			<section>
				<h3>Data Encapsulation</h3>
				<p>Data Encapsulation is to hide or restrict direct access to an object's members</p>
				<p>Instead of direct access a set of accessor and modifier methods are used to interact with the data.</p>
			</section>
			<section>
				<h3>Benefits</h3>
				<ol>
					<li>Control to make fields read-only and write-only</li>
					<li>Classes can have absolute control over what is stored in the field</li>
					<li>Provides a layer of abstraction.  Users of the class (other code or objects) do not need to know the details of the data storage</p>
				</ol>
			</section>
			<section>
				<aside class='notes'>
					Change from public to private:<br>
					private boolean engineOn;  
				</aside>
				<h3>Encapsulating our Data</h3>
				<p>Let's make all our data members private</p>
				<p>Now we'll need to add accessor methods so we can still access the data</p>
			</section>
			<section>
				<aside class='notes'>
					public boolean getEngineOn(){<br>
					return engineOn;<br>
					}<br>
				</aside>
				<h3>Code It!</h3>
				<p>Add an accessor method to get the current speed: </p>
				<pre><code class='java'>
public int getCurrentSpeed() {
	return currentSpeed;
}
				</code></pre>
				<p><span class='individually'>On your own,</span> add an accessor method for the boolean engineOn</p>
			</section>
			<section>
				<pre><code class='java'>
public boolean getEngineOn() {
	return engineOn;
}
				</code></pre>
			</section>
			<section>
				<aside class='notes'>
					System.out.println("Engine is On: "+myVehicle.getEngineOn());<br>
					System.out.println("Current Speed: "+myVehicle.getCurrentSpeed());<br>
					myVehicle.accelerate();<br>
					System.out.println("Current Speed: "+myVehicle.getCurrentSpeed());<br>
					myVehicle.decelerate();<br>
					System.out.println("Current Speed: "+myVehicle.getCurrentSpeed());<br>
				</aside>
				<h3>Update our Code</h3>
				<p>Now instead of calling on your data members directly, use the accessor methods we just created to get their values.</p>
				<pre><code class='java'>
System.out.println("Current Speed: " + myVehicle.getCurrentSpeed());
				</code></pre>
			</section>
		</section>
		<section>
			<section>
				<h3>Static vs Instance</h3>
				<p>When a method is declared static, it is <strong>shared</strong> by all instances of the class.</p>
				<p>In contrast, the type of methods we've been using have been <strong>unique</strong> to each instance.</p>
			</section>
		</section>
		<section>
			<section>
				<aside class='notes'>
					The constructor
				</aside>
				<h3>Static: An Example</h3>
				<p>How many cars on the road?</p>
				<p>Create a static data member to keep count of the MotorVehicles we've created: </p>
				<pre><code class='java'>
private static int countCreated = 0;
				</code></pre>
				<p>Each time a MotorVehicle is created we want to increment the count.</p>
				<p>Where would we put the code to do so?</p>
			</section>
			<section>
				<h3>Code It</h3>
				<pre><code class='java'>
public MotorVehicle() {
	currentSpeed = 0;
	engineOn = false;
	countCreated++;
}
				</code></pre>
			</section>
			<section>
				<h3>Add an Accessor</h3>
				<p>We can create a regular accessor method to return the countCreated.</p>
				<pre><code class='java'>
public int getCountCreated() {
	return countCreated;
}
				</code></pre>
				<p><span class='individually'>On your own,</span> print the countCreated</p>
			</section>
			<section>
				<h3>The Code</h3>
				<pre><code class='java'>
System.out.println("Number of vehicles on the road: " +
	myVehicle.getCountCreated());
				</code></pre>
			</section>
			<section>
				<aside class='notes'>
					Note that they are the same because they are referencing the same data member
				</aside>
				<h3>Testing our Static Data Member</h3>
				<ol>
					<li>Create a second MotorVehicle myVehicle2</li>
					<li>Print the result of myVehicle.getCountCreated()</li>
					<li>Print the result of myVehicle.getCountCreated()</li>
				</ol>
			</section>
		</section>
		<section>
			<section>
				<h3>Static Method</h3>
				<p>Since the <em>countCreated</em> is not specific to the instance, we might want to make a method that is not specific to the instance when accessing the data.</p>
				<p>We can create static methods that (like a static data member) is shared by all instance.</p>
			</section>
			<section>
				<h3>Code It</h3>
				<p>Add the static keyword to your method declaration: </p>
				<pre><code class='java'>
public static int getCountCreated() {
	return countCreated;
}
				</code></pre>
			</section>
			<section>
				<aside class='notes'>
					System.out.println("Number of Vehicles: "+MotorVehicle.getCountCreated());<br>
					MotorVehicle myVehicle2 = new MotorVehicle();<br>
					System.out.println("Number of Vehicles: "+MotorVehicle.getCountCreated());
				</aside>
				<h3>Accessing the static method</h3>
				<p>You can access a static method the same way you access an instance method, but it is discouraged since it doesn't clearly indicate you accessing a class method.</p>
				<p>Instead, we will update our code to use this format: </p>
				<pre><code class='java'>
ClassName.staticMethodName();
				</code></pre>
			</section>
			<section>
				<h3>The Code</h3>
				<pre><code class='java'>
System.out.println("Number of Vehicles: " +
	MotorVehicle.getCountCreated());

MotorVehicle myVehicle2 = new MotorVehicle();

System.out.println("Number of Vehicles: " +
	MotorVehicle.getCountCreated());
				</code></pre>
			</section>
		</section>
		<section>
			<h3>Checkpoint</h3>
			<ul>
				<li>Data Encapsulation</li>
				<li>Static vs Instance</li>
			</ul>
		</section>
		<section>
			<section>
				<h3>Inheritance and Subclasses</h3>
				<p>A class can be derived from another class</p>
				<p>A class that is derived from another class is called a <em>subclass</em></p>
				<p>Subclasses inherit fields and methods from their parent class</p>
			</section>
			<section>
				<h3>Why would you want it?  Inheritance</h3>
				<p>New class is created from an existing class</p>
				<p>Reuse code</p>
				<p>Can be used to create a hierarchical class structure</p>
			</section>
			<section>
				<h3>MotorVehicle -> Car</h3>
				<p>Let's create a car</p>
				<p>File > New > Class</p>
				<p>Name: Car</p>
				<p>Add the extends keyword and the name of the parent class (MotorVehicle)</p>
				<pre><code class='java'>
public class Car extends MotorVehicle {
	...
}
				</code></pre>
			</section>
			<section>
				<h3>What you can do with a Subclass</h3>
				<p>You can write a subclass constructor that invokes constructor of the superclass</p>
				<p>You can declare new fields in subclass that aren't in the parent class</p>
				<p>Inherited fields can be used directly</p>
				<p>A subclass can't inherit private members</p>
			</section>
		</section>
		<section>
			<section>
				<h3>Super</h3>
				<p>The Super keyword can be used in a child to call a method or member of the parent class</p>
				<p>The syntax is super.methodName() or super.memberName;</p>
				<p>If you want to call the constructor of the super class you simply use the syntax: </p>
				<pre><code class='java'>
super();
				</code></pre>
			</section>
			<section>
				<aside class='notes'>
					public Car(){<br>
					super();<br>
					}
				</aside>
				<h3>Code It!</h3>
				<p>Create a car constructor that calls super()</p>
			</section>
			<section>
				<h3>The Code</h3>
				<pre><code class='java'>
public class Car extends MotorVehicle {
	public Car() {
		super();
	}
}
				</code></pre>
			</section>
		</section>
		<section>
			<section>
				<aside class='notes'>
					For instance, while a motor boat doesn't necessarily have a door or a trunk all cars do
				</aside>
				<h3>What else can you do with a subclass?</h3>
				<p>You can declare new fields in subclass that aren't in the parent class.</p>
			</section>
			<section>
				<aside class='notes'>
					public class Car extends MotorVehicle {<br>
					<strong>private boolean trunkOpen;<br>
					private int numDoors;</strong><br>
					public Car() {<br>
					super();<br>
					}<br>
					}
				</aside>
				<h3>Code It!</h3>
				<ol>
					<li>Add a boolean called trunkOpen</li>
					<li>Add an int called numDoors</li>
				</ol>
			</section>
			<section>
				<h3>The Code</h3>
				<pre><code class='java'>
public class Car extends MotorVehicle {
	private boolean trunkOpen;
	private int numDoors;
	
	public Car() {
		super();
	}
}
				</code></pre>
			</section>
			<section>
				<aside class='notes'>
					public Car() {<br>
					super();<br>
					<strong>trunkOpen = false;<br>
					numDoors = 4;</strong><br>
					}
				</aside>
				<h3>Augment the constructor</h3>
				<p>Our constructor should also be initialize the subclass-only data members</p>
				<p>Initialize trunkOpen to false and numDoors to 4</p>
			</section>
			<section>
				<h3>The Code</h3>
				<pre><code class='java'>
public class Car extends MotorVehicle {
	private boolean trunkOpen;
	private int numDoors;
	public Car() {
		super();
		trunkOpen = false;
		numDoors = 4;
	}
}
				</code></pre>
			</section>
			<section>
				<aside class='notes'>
					Car myCar = new Car();<br>
					myCar.switchEngineState();<br>
					System.out.println(myCar.getCurrentSpeed());<br>
					myCar.accelerate();<br>
					System.out.println(myCar.getCurrentSpeed());<br>
					myCar.printDescription();<br>
					System.out.println("Number of Vehicles: "+MotorVehicle.getCountCreated());
				</aside>
				<h3>Test it Out</h3>
				<p>In your HelloWorld class:</p>
				<ol>
					<li>Create a car "myCar"</li>
					<li>Turn the engineOn</li>
					<li>Print the car's current speed</li>
					<li>Accelerate the car</li>
					<li>Print the car's new current speed</li>
					<li>Call printDescription</li>
					<li>Print the count of MotorVehicles on the road</li>
				</ol>
			</section>
			<section>
				<aside class='notes'>
					Highlight that we now have 3 motor vehicles<br>
					Trace through calling the parent's constructor and methods<br>
					Car must be rolling down the street...someone forgot the emergency break
				</aside>
				<h3>The Code</h3>
				<pre><code class='java'>
Car myCar = new Car();
myCar.switchEngineState();
System.out.println(myCar.getCurrentSpeed());
myCar.accelerate();
System.out.println(myCar.getCurrentSpeed());
myCar.printDescription();
System.out.println("Number of Vehicles on the road: " +
	MotorVehicle.getCountCreated());
				</code></pre>
				<p>Output:</p>
				<pre><code class='no-highlight'>
0
5
I'm a Motor Vehicle and my Engine is on true and I'm going 5 mph
Number of Vehicles on the road: 3
				</code></pre>
			</section>
			<section>
				<h3><span class='individually'>Individually</span></h3>
				<p>Add accessor methods for:</p>
				<ol>
					<li>trunkOpen</li>
					<li>numDoors</li>
				</ol>
				<p>Call the methods in the Tester</p>
			</section>
			<section>
				<h3>Code</h3>
				<pre><code class='java'>
public boolean getTrunkOpen() {
	return trunkOpen;
}

public int getNumDoors() {
	return numDoors;
}
				</code></pre>
				<pre><code class='java'>
System.out.println("number doors: " + myCar.getNumDoors());
System.out.println("the trunk is open: " + myCar.getTrunkOpen());
				</code></pre>
			</section>
		</section>
		<section>
			<section>
				<aside class='notes'>
					Optionally have the  @Override notation<br>
					Potentially useful since it shows up in all my android projects a # of times..
				</aside>
				<h3>Overriding Methods</h3>
				<p>Instance Methods:</p>
				<p>An instance method in a subclass (child class) that has the same signature and return type as an instance method in the superclass <em>overrides</em> the superclass's method.</p>
			</section>
			<section>
				<h3>Code It</h3>
				<ol>
					<li>In the Tester, call the printDescription() method for your car</li>
					<li>Run it</li>
					<li>Create a printDescription() method for your car class that says:<em>
						I'm a car!  I have (#) doors!</em></li>
				</ol>
			</section>
			<section>
				<aside class='notes'>
					If we comment out the printDescription() code in Car, the code calls the printDescription() of the parent class<br>
					uncomment and it uses the car<br>
					Any questions?
				</aside>
				<h3>Overriding Methods Cont.</h3>
				<p>The output of myCar.printDescription() now says: </p>
				<pre><code class='no-highlight'>
I'm a car!  I have 4 doors!
				</code></pre>
			</section>
		</section>
		<section>
			<section>
				<h3>Final Methods</h3>
				<p>A Final method cannot be overridden in a subclass</p>
			</section>
			<section>
				<h3>Test it</h3>
				<p>Add the <em>final</em> keyword to the printDescription() method inside of the MotorVehicle class</p>
				<pre><code class='java'>
public final void printDescription() {...}
				</code></pre>
				<p>The implication is that the subclass, Car, cannot override the printDescription()</p>
				<p>Observe the compiler error</p>
			</section>
		</section>
		<section>
			<section>
				<h3>A moment to ponder</h3>
				<p>Right now we can accelerate and decelrate our car by the default value of "5"</p>
				<p>What if we wanted to really slam on the pedal and take a 10 mph jump? Or 20??</p>
				<p>We can create another accelerate/decelerate method that will take a parameter specifying how much faster or slower we want to go</p>
			</section>
			<section>
				<h3>Method Overloading</h3>
				<p>Doing so is called <em>Method Overloading</em></p>
				<pre><code class='java'>
public void accelerate(int amount) {
	currentSpeed = currentSpeed + amount;
}
				</code></pre>
				<p>Overloading is summed up by: Same name and different parameter list</p>
			</section>
			<section>
				<h3>An Error?</h3>
				<p><em>The field MotorVehicle.currentSpeed is not visible</em></p>
				<p>We've seen something like this before...it has to do with those access modifiers</p>
			</section>
		</section>
		<section>
			<section>
				<aside class='notes'>
					Protected is also accessed by classes in the same package
				</aside>
				<h3>Fields</h3>
				<p>Inherited Fields</p>
				<p>A subclass can't access a parent's private members</p>
				<p>There is a third access modifier called Protected</p>
				<p>Protected fields can be accessed by subclasses</p>
			</section>
			<section>
				<h3>Quick Detour</h3>
				<p>Hop back to the MotorVehicle class and update your private member "currentSpeed" to protected.</p>
				<p>Now that the error has gone, test out your new method: </p>
				<pre><code class='java'>
myCar.accelerate(10);
System.out.println(myCar.getCurrentSpeed());
				</code></pre>
			</section>
			<section>
				<h3><span class='individually'>Individually</span></h3>
				<p>Overload the decelerate method in the same fashion</p>
			</section>
			<section>
				<h3>The Code</h3>
				<pre><code class='java'>
public void decelerate(int amount) {
	currentSpeed = currentSpeed - amount;
}
				</code></pre>
			</section>
		</section>
		<section>
			<aside class='notes'>
				Polymorphism can be a bit of an advanced topic since it's really covers a lot of ground with various types<br>
				We want to mention it so they can say "ooooh yeah I've heard of that"  not much to do with it in java
			</aside>
			<h3>Polymorphism</h3>
			<p>Assuming a subclass has overloaded a method in the parent class:</p>
			<p><em>"When an application needs the function, the particular version is dynamically determined at runtime"</em> - William Ford, William Topp Data Structures with C++ using STL</p>
		</section>
		<section>
			<section>
				<h3>Abstraction</h3>
				<p>Using the <em>abstract</em> keyword when developing a class indicates that the class will never be instantiated</p>
				<p>However, other classes that extend (inherit) the abstract class (if not abstract themselves) could be instantiated</p>
			</section>
			<section>
				<aside class='notes'>
					No<br>
					You have cars<br>
					Trucks<br>
					Buses<br>
					But nothing that's just a generic MotorVehicle
				</aside>
				<h3>Building an Abstract Class</h3>
				<p>Abstract classes can contain partial implementations</p>
				<p>Will you ever have just a <em>MotorVehicle</em> on the road?</p>
			</section>
			<section>
				<h3>Code It!</h3>
				<p>Convert our MotorVehicle class to an Abstract Class</p>
				<p>Add the <em>abstract</em> keyword to the class declaration:</p>
				<pre><code class='java'>
public abstract class MotorVehicle { ... }
				</code></pre>
			</section>
			<section>
				<h3>Updating our Tests</h3>
				<p>Now that MotorVehicle is an abstract class, we can't create an instance of it</p>
				<p>We have two choices:</p>
				<ol>
					<li>Comment out the code</li>
					<li>Update the code to create instances of Cars</li>
				</ol>
			</section>
			<section>
				<aside class='notes'>
					Flexibility -- MotorVehicle could be used as a parameter in methods  and any MotorVehicle (regardless of subtype) could be passed when declared like this<br>
					<br>
					Polymorphism
				</aside>
				<h3>Updating Cont.</h3>
				<p>Since car extends MotorVehicle we can:</p>
				<pre><code class='java'>
MotorVehicle myVehicle = new Car();
MotorVehicle myVehicle2 = new Car();
				</code></pre>
				<p>Why would you want to do this?</p>
			</section>
		</section>
		<section>
			<aside class='notes'>
				Hiding really only matters if you used the parent class type when declaring a new instace of a subclass<br>
				i.e.<br>
				MotorVehicle myOtherCar = new Car();<br>
				<br>
				If we call myOtherCar.staticMethod() it will look at the declared type "MotorVehicle" and call that static method
			</aside>
<!--
			<h3>Hiding Methods</h3>
			<p>Class Methods:</p>
			<p>If a subclass defines a class method with the same signature as a class method in the superclass, the method in the subclass hides the one in the superclass</p>
		</section>
		<section>
-->
			<aside class='notes'>
				Give them plenty of time to play around with creating their own subclass<br>
				Encourage them to use the concepts discussed
			</aside>
			<h3>Code It!</h3>
			<p><span class='individually'>On your own,</span> create a Bus that extends MotorVehicle</p>
			<p>Additional Bus specific Methods to include: </p>
			<ol>
				<li>pickUpPassengers(int numer)</li>
				<li>dropOffPassengers()</li>
			</ol>
		</section>
		<section>
			<aside class='notes'>
				Circle back to our initial discussion on what it takes to be a motor vehicle and relate that to our motorvehicle<br>
				ALSO  -- how will other people interact with our class? An interface could tell them
			</aside>
			<h3>Interfaces</h3>
			<p>If an abstract class only contains abstract method declarations, it is an interface</p>
			<p>An <em>interface</em> tells people how to interact with an object</p>
			<p>What are the methods?  What are the parameters do they need and what do they return?</p>
		</section>
		<section>
			<h3>Where to go from here?</h3>
		</section>
	</div> <!-- end slides -->
	<footer>
		<span class='footer-title'>Intro to OOP with Java</span>
		<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/80x15.png" /></a>
	</footer>
	</div> <!-- end reveal -->
	<script src="reveal/lib/js/head.min.js"></script>
	<script src="reveal/js/reveal.min.js"></script>

	<script>
		// Full list of configuration options available here:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,

			theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
			transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/none

			// Optional libraries used to extend on reveal.js
			dependencies: [
				{ src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: 'reveal/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
				{ src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				{ src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
			]
		});

	</script>
</body>
</html>
